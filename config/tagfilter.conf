input {
    zeromq {
            # These configs are from the inputs/base
            format => "json"
            type => "metlog"

            # The configuration below is specific to the zeromq input
            # source
            # This is the binding configuration for the listener
            # TODO: change this to a zeromq bind string
            zeromq_bind => "tcp://127.0.0.1:5565"

            # This is an optional parameter to set the input queue
            # length so that messages don't eat all memory because of
            # 0mq's default setting
            queue_length => 5
    }
}

filter {
    # The tagger uses a path notation to traverse JSON dictionaries

    # 'Large' events. Route them to sentry or bagheera

    # This tagger matches on event['metadata']['some_data'] for values
    # of 'foo' and then tags the event to be processed as a sentry
    # event
    tagger {
        type => "metlog"
        pattern => [ "fields/some_data", "foo" ]
        add_tag => [ "metlog_dest_sentry" ]
    }

    # This tagger matches on event['logger'] for values
    # of 'toy2' and then tags the event to be processed as a bagheera
    # event.
    tagger {
        type => "metlog"
        #  Capture everything
        pattern => [ "logger", "*" ]
        add_tag => [ "metlog_dest_bagheera" ]
    }

    # TODO: we probably need a wildcard match to throw arbitrary stuff
    # into bagheera


    #######
    # Operational Metrics below

    tagger {
        # This tagger filter captures counters of severity 0
        # exceptions
        type => "metlog"
        pattern => [ "type", "counter",
                     "severity", "0"]
        add_tag => ["metlog_dest_statsd_exceptions"]
    }

    tagger {
        # This tagger filter captures counters of severity 0
        # exceptions
        type => "metlog"
        pattern => [ "fields/type", "timer"]
        add_tag => [ "metlog_dest_statsd_timer" ]
    }
}

output {
    # this sends messages into a queuing mechanism that will
    # send messages out as POST messages.  This is what bagheera will
    # expect to happen
    http {
        # Only pick up messages with this tag
        match_tag => "metlog_dest_sentry"

        # POST URL to send JSON blob to
        # Sentry doesn't use REST apparently, so this isn't all that useful to
        # look at, other than to verify that we've got multiple output streams
        # running concurrently
        url_string => "http://localhost:8080/"
    }

    http {
        # Only pick up messages with this tag
        match_tag => "metlog_dest_bagheera"

        # TODO: the bagheera API expects a unique-id at the end of the URL.
        # need to get a real bagheera instance running to resolve this
        # properly

        # Note that the port corresponds to the one specified in the
        # bagheera startup script
        url_string => "http://localhost:9080/map/demo/"
    }


    #

    metlog_statsd {

        # Only pick up timers
        tags => ["metlog_dest_statsd_timer"]

        # Locate the statd server
        host => '127.0.0.1'
        port => 8125
    }

    metlog_file {
        # pick up everything
        path => "/tmp/logstash/metlog.log"
    }

}
